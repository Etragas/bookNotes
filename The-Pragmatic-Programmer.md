## Smarter Faster Better
by Charles Duhigg

### Theme 1: Communicating problems
* pg 3: Try to always practice a conversation before you have it with someone else. Anticipate their response their most likely responses and think through what you would say in return. If your predictions are wrong, thing about what that means

* pg 4: If you only show up with problems, you're not doing it right. You should be getting paid to think in lieu of the person you're meeting with, otherwise you're replacable. As a consequence, you only want to have a meeting when you have problems and actionable next steps.

### Theme 2: Automation
* pg 232: Remember to use hierarchical makes 
#### Summary
	Self-motivation is the result of connecting insignificant and small actions to a larger meaning. 
	Getting into the habit of reframing those small events into an important whole is how someone 
	continues to improve.
	
	
#### Lyon's Notes

Allowing a small portion of code to be poor quality with no effort or declared intention of fixing it opens the flood gates to more poor code

Trick people into working on something you think is important by implementing a part of it (as much as you reasonably can) well. Show it off. Get people to want to contribute to it, at first in a small way, and then more as it gains popular support/interest

Treat your knowledge and skills as an investment portfolio. Diversify. Invest frequently.  Diversify risk (some high, some low). Buy low sell high (acquire the next gig demand skills

This book is very biased towards the shotgun approach to learning. Basically says: learn everything, maybe it will be useful

Make code easy to reuse. This prevents future duplication

Write orthogonal solutions to things. Maintainability, extensibility, reusability, reduced side effects, and risk, easier to test

Teams should be orthogonal too. At least to the extent that you get people out of each other's ways

A project is never finished, it will always need modification and extension. Design projects with this in mind

When starting a project, prototype it while designing it. See if there's something you haven't considered

Consider prototyping in a higher level language. If your prototype is meant to be disposable that is

Explaining problems/bugs to other people can be a good way to discover gaps in your knowledge, or assumptions you've made

Instead of gathering detailed requirements, you can gather detailed use cases, and generate the requirements needed off those

Civilization advances by extending the number of important operations we can preform without thinking - Alfred north Whitehead



